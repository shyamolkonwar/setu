# üìò Upstash Integration Documentation

**Project:** AI Website Operator Platform
**Purpose:** Rate limiting, abuse control, and queue safety
**Status:** Free-first, no payments

---

## 1. Why Upstash Is Used in This Project

This platform is **free to try**, AI-heavy, and publicly accessible.
That makes it vulnerable to:

* Automated abuse
* Excessive AI usage
* Cost explosions
* Queue flooding
* Multi-account exploitation

Upstash Redis is used as a **lightweight, global control layer** to:

* Enforce rate limits
* Throttle expensive actions
* Protect Celery workers
* Track abuse signals
* Maintain system stability

Upstash is **not** used for business data or persistence.
It is used only for **short-lived control state**.

---

## 2. What Role Upstash Plays in the Architecture

![Image](https://thealgoristsblob.blob.core.windows.net/thealgoristsimages/rate-limiter-sys-design-3.jpeg)

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2AnBXfm6BcTvyfPf0f9MJ_-Q.jpeg)

![Image](https://derlin.github.io/introduction-to-fastapi-and-celery/assets/03-celery.excalidraw.png)

### High-level position

```
User
 ‚Üì
Cloudflare (IP & bot protection)
 ‚Üì
FastAPI (auth + logic)
 ‚Üì
Upstash Redis (rate & behavior checks)
 ‚Üì
Credits system (Supabase)
 ‚Üì
Celery queue
 ‚Üì
AI workers
```

Upstash acts as a **gatekeeper**, not a processor.

---

## 3. What Upstash Is NOT Used For

To avoid confusion, Upstash is **not** used for:

* User authentication
* User profiles
* Website data
* Billing
* Long-term storage
* Analytics
* Content storage

All permanent data lives in **Supabase**.

---

## 4. Where Upstash Is Integrated in the Project

Upstash is integrated at **four strategic points** in the system.

---

### 4.1 API-Level Rate Limiting (Primary Use)

**Location:** FastAPI request handling layer

**Purpose:**
Prevent users from calling sensitive endpoints too frequently.

**Examples of protected actions:**

* Website generation
* Voice uploads
* Redesign requests
* Bulk regeneration
* Dashboard API calls

**How it works conceptually:**

* Each request is mapped to a **user + action**
* A counter is incremented in Upstash
* If the counter exceeds a threshold within a time window:

  * Request is rejected
  * AI is never triggered

This ensures **AI jobs are never started unnecessarily**.

---

### 4.2 Celery Queue Protection (Critical)

**Location:** Before enqueuing Celery tasks

**Purpose:**
Protect background workers from overload or flooding.

**Why this is needed:**

* FastAPI is fast
* AI jobs are slow
* Without protection, users could enqueue hundreds of tasks

**Rule enforced:**

> No task is added to Celery unless it passes Upstash checks.

Upstash ensures:

* Max active jobs per user
* Cooldowns between jobs
* No parallel abuse

---

### 4.3 Abuse Signal Tracking (Behavioral Control)

**Location:** Backend logic layer

**Purpose:**
Track suspicious or abusive behavior patterns over time.

**Signals tracked via Upstash:**

* Rapid repeated regenerations
* High failure rates
* Excessive retries
* Multiple actions in short windows
* Repeated limit violations

These signals:

* Increment short-lived counters
* Automatically expire
* Feed into an **abuse score**

Upstash is ideal here because:

* No schema needed
* No cleanup required
* Low latency
* Cheap to operate

---

### 4.4 Distributed Consistency Across Instances

**Location:** Infrastructure-wide

**Purpose:**
Ensure rate limits apply **globally**, not per server.

Because the backend can run:

* Multiple FastAPI instances
* Multiple Celery workers

Upstash provides:

* Shared counters
* Global state
* No instance-level inconsistencies

This is essential even at small scale.

---

## 5. Relationship Between Upstash and Other Systems

### Upstash vs Supabase

| Concern           | Supabase | Upstash |
| ----------------- | -------- | ------- |
| User identity     | ‚úÖ        | ‚ùå       |
| Business data     | ‚úÖ        | ‚ùå       |
| Long-term storage | ‚úÖ        | ‚ùå       |
| Rate limits       | ‚ùå        | ‚úÖ       |
| Abuse counters    | ‚ùå        | ‚úÖ       |
| Credits balance   | ‚úÖ        | ‚ùå       |

Supabase = **truth**
Upstash = **control**

---

### Upstash vs Cloudflare

| Layer      | Purpose                |
| ---------- | ---------------------- |
| Cloudflare | Blocks bots & bad IPs  |
| Upstash    | Controls user behavior |

Cloudflare acts **before authentication**.
Upstash acts **after authentication**.

They complement each other.

---

## 6. Rate Limiting Strategy (Conceptual)

Rate limits are applied **by action**, not generically.

### Example categories:

* General API usage
* Website creation
* Voice processing
* Redesign actions
* Publish actions

Each category:

* Has its own limit
* Has its own time window
* Is enforced independently

This avoids punishing normal users while stopping abuse.

---

## 7. Key Design Principles for Upstash Usage

1. **Fail early**
   Requests are blocked before any AI or heavy logic runs.

2. **Fail gently**
   Users see clear, human messages ‚Äî not technical errors.

3. **Fail temporarily**
   Limits reset automatically via TTL.

4. **No permanent punishment**
   Abuse is throttled, not banned, in early stages.

---

## 8. Failure Handling Policy

If Upstash is temporarily unavailable:

* The system fails **open but safe**
* Minimal requests are allowed
* AI-heavy actions remain protected
* Event is logged for review

The platform should **never fully stop** because of Upstash.

---

## 9. Operational Benefits of Using Upstash

* No Redis servers to manage
* No scaling decisions
* No maintenance
* No cleanup jobs
* Predictable cost
* Global availability

This aligns with the project‚Äôs **lean MVP philosophy**.

---

## 10. When Upstash Limits Will Be Tightened

Upstash limits are expected to evolve:

* Early launch ‚Üí slightly generous
* Public traction ‚Üí stricter
* Paid plans ‚Üí differentiated limits
* Enterprise users ‚Üí custom rules

Upstash enables this without schema or infra changes.

---

## 11. Summary

Upstash is used in this project to:

* Protect free access
* Control AI costs
* Prevent queue abuse
* Enforce fair usage
* Maintain system stability

It is a **control layer**, not a data layer.

---

## 12. Internal Guiding Rule

> **If an action can cost money,
> it must pass through Upstash first.**

This rule should guide all future feature development.

---

5Ô∏è‚É£ Connect Upstash to Celery
Celery Configuration (FastAPI)
In celery_app.py:
from celery import Celery
import os

celery_app = Celery(
    "worker",
    broker=os.getenv("REDIS_URL"),
    backend=os.getenv("REDIS_URL"),
)

celery_app.conf.update(
    task_track_started=True,
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    task_time_limit=600,
)
‚úÖ Celery now uses Upstash Redis
‚úÖ No local Redis needed
‚úÖ Works in production immediately
6Ô∏è‚É£ Install Upstash Redis Client (For Rate Limiting)
pip install upstash-redis
7Ô∏è‚É£ Create Rate Limiting Utility (Core Logic)
Create file:
app/core/rate_limit.py
from upstash_redis import Redis
import os
import time

redis = Redis(
    url=os.getenv("UPSTASH_REDIS_REST_URL"),
    token=os.getenv("UPSTASH_REDIS_REST_TOKEN"),
)

def is_rate_limited(key: str, limit: int, window_seconds: int):
    now = int(time.time())
    window_key = f"{key}:{now // window_seconds}"

    count = redis.incr(window_key)
    if count == 1:
        redis.expire(window_key, window_seconds)

    return count > limit
This is:
Fast
Serverless
Auto-expiring
No cleanup needed
8Ô∏è‚É£ Apply Rate Limiting in FastAPI
Example: Website Generation Endpoint
from app.core.rate_limit import is_rate_limited
from fastapi import HTTPException

@router.post("/generate")
def generate_website(user=Depends(get_user)):
    key = f"user:{user.id}:generate"

    if is_rate_limited(key, limit=2, window_seconds=3600):
        raise HTTPException(
            status_code=429,
            detail="You‚Äôve reached the hourly limit. Try again later."
        )

    # enqueue Celery task here
This ensures:
Abuse is blocked
AI never runs unnecessarily
Cost is protected
9Ô∏è‚É£ Protect Celery Task Enqueue (DOUBLE SAFETY)
Before enqueueing any task, always check rate limits.
Why?
Prevent race conditions
Prevent bypass via parallel requests
Golden rule:
No task goes into Celery without passing Upstash check
üîü Rate Limit Rules (Recommended Defaults)
Action	Limit
API requests	60 / min
Website generation	2 / hour
Voice input	5 / hour
Redesign	1 / day
Publish	Unlimited
You can tighten later.
1Ô∏è‚É£1Ô∏è‚É£ Use Upstash for Abuse Counters (Smart Move)
Store signals like:
abuse:user:{user_id}:failed_jobs
abuse:user:{user_id}:rapid_requests
Increment on suspicious behavior.
If counter crosses threshold:
Soft block
Warning
Cooldown
No database writes needed.